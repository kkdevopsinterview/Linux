## 1) You accidentally deleted an important file. How would you recover it in Linux?

### Scenario
An application log/config was deleted from an ext4 filesystem. No recent backup exists.

### Key Facts
- On **ext4/XFS**, `rm` drops directory entries and decrements inode links; data blocks may still be on disk until overwritten.
- Recovery chances drop rapidly if the filesystem stays mounted and continues writing.

### Immediate Actions (Increase Success Probability)
1. Stop writes to that filesystem:
   ```bash
   sync
   mount | grep ' /data '   # identify mount
   sudo umount /data        # if possible
````

If unmounting isn’t feasible (root FS), remount read-only:

```bash
sudo mount -o remount,ro /
```

2. Capture disk image (so we can attempt recovery offline):

   ```bash
   sudo dd if=/dev/sdX of=/mnt/recovery/disk.img bs=4M conv=sync,noerror status=progress
   ```

### Recovery Approaches

* **extundelete (ext3/ext4 only, needs unmounted FS or image):**

  ```bash
  sudo extundelete /dev/sdX --restore-file /path/to/important.conf
  # Or to attempt many files:
  sudo extundelete /dev/sdX --restore-directory /path/to/dir
  ```
* **testdisk/photorec (file-carving; format/headers based; not path-aware):**

  ```bash
  sudo photorec /log
  ```
* **LVM snapshots (if preconfigured):**

  ```bash
  lvcreate -s -n rec_snap -L 5G /dev/vg/lvdata
  mount /dev/vg/rec_snap /mnt/snap
  cp /mnt/snap/important.conf /restore/
  ```

### If It Was Still Open by a Process (common for logs)

You can often recover the content from the process’ open file descriptor:

```bash
# Find the process with the deleted file
sudo lsof | grep '(deleted)' | grep important.log
# Suppose PID=1234 and fd=4:
sudo cat /proc/1234/fd/4 > /tmp/important.log.recovered
```

### Preventive Controls

* Enable app log rotation to a safe location; ship to remote (rsyslog/Fluent Bit).
* Use filesystem snapshots (LVM, ZFS, btrfs) and backups (Borg/Restic).

### Interview Angle

Explain the order: freeze writes → snapshot/image → file-system-aware tools (extundelete) → generic carving (photorec) → special case via `/proc/<pid>/fd`.

---

## 2) A user reports they cannot access a file even though they have read permissions. What could be the issue?

### Common Root Causes

1. **Parent directory execute (search) bit missing** — user needs `x` on all parent dirs.
2. **ACLs override standard perms** — a deny ACL may block access.
3. **SELinux/AppArmor policy** denies read.
4. **Filesystem mounts with `nosuid/nodev/noexec`** (rarely blocks read, but exec scripts may fail).
5. **NFS root_squash or UID/GID mismatch** on network mounts.

### Systematic Checks

```bash
# Standard perms and path walk
namei -l /path/to/file

# ACLs
getfacl /path/to/file
getfacl /path/to/parent

# SELinux context and denials
ls -Z /path/to/file
sudo ausearch -m avc -ts recent | less

# AppArmor profile status (Ubuntu/SUSE)
aa-status

# NFS mapping and export options (on client)
mount | grep nfs
id username
```

### Fix Examples

* Add execute on parent dir:

  ```bash
  chmod o+x /path/to
  ```
* Adjust ACL:

  ```bash
  setfacl -m u:student:r /path/to/file
  ```
* Align SELinux context with defaults:

  ```bash
  sudo restorecon -Rv /path/to
  ```

### Interview Angle

Mention the **directory execute bit** for path traversal and **ACL/SELinux** as common invisible blockers.

---

## 3) You need to find and delete all log files older than 30 days.

### Command

```bash
sudo find /var/log -type f -name '*.log' -mtime +30 -print -delete
```

### Safer Two-Step (dry run then delete)

```bash
find /var/log -type f -name '*.log' -mtime +30 -print
# if output looks correct
find /var/log -type f -name '*.log' -mtime +30 -delete
```

### With Compressed Logs and Journals

```bash
find /var/log -type f \( -name '*.log' -o -name '*.gz' \) -mtime +30 -delete
sudo journalctl --vacuum-time=30d
```

### Interview Angle

Emphasize a dry run, constrained paths, and handling journalctl separately.

---

## 4) A directory has thousands of files, and `rm -rf` is taking too long. How can you speed it up?

### Techniques

* **Use `rsync --delete` trick** (fast directory wipe):

  ```bash
  mkdir -p /empty && rsync -a --delete /empty/ /bigdir/
  rmdir /empty
  ```
* **Use `find` with `-delete`** to avoid argv blow-ups:

  ```bash
  find /bigdir -type f -delete
  find /bigdir -type d -empty -delete
  ```
* **Use `xargs` with batching and parallelism**:

  ```bash
  find /bigdir -type f -print0 | xargs -0 -P 8 rm -f
  ```
* **Filesystem-specific**: On btrfs:

  ```bash
  btrfs subvolume delete /bigdir
  ```

### Interview Angle

Argue for **minimizing per-file metadata ops**, using tools that batch syscalls, and, where applicable, subvolume/snapshot drop.

---

## 5) How do you find the top 10 largest files on your Linux system?

### Commands

```bash
# Top 10 largest files under root (skipping pseudo filesystems)
sudo du -x -h / 2>/dev/null | sort -hr | head -n 50 | head
# More precise (files only) under a path:
sudo find / -xdev -type f -printf '%s %p\n' 2>/dev/null | sort -nr | head -n 10
```

### Practical Variant (specific mount)

```bash
find /var -type f -printf '%s %p\n' 2>/dev/null | sort -nr | head -n 10
```

### Interview Angle

Note `-xdev` to stay on the same filesystem and `-printf` for speed.

---

## 6) A script is failing with "permission denied", even as root. What could be the reason?

### Likely Causes

1. **No execute bit on the script**:

   ```bash
   chmod +x script.sh
   ```
2. **Wrong shebang or CRLF line endings**:

   ```bash
   head -1 script.sh           # verify shebang: #!/usr/bin/env bash
   file script.sh              # look for CRLF
   dos2unix script.sh
   ```
3. **Filesystem mount with `noexec`**:

   ```bash
   mount | grep noexec
   # Remount or move script to exec-enabled FS
   ```
4. **SELinux denial**:

   ```bash
   sealert -a /var/log/audit/audit.log  # or check ausearch
   restorecon -Rv /path/to/script
   ```
5. **Interpreter missing**:

   ```bash
   which bash python perl
   ```

### Interview Angle

List the ladder: perms → line endings → mount options → SELinux → interpreter.

---

## 7) Rename multiple files that have spaces in their names.

### Safe, Portable Approach (rename spaces to underscores)

```bash
find . -maxdepth 1 -type f -name '* *' -print0 \
  | while IFS= read -r -d '' f; do
      mv -i "$f" "${f// /_}"
    done
```

### Using `rename` (Perl-based; distro dependent)

```bash
# Debian/Ubuntu typically:
rename 's/ /_/g' *\ *
# RHEL/Fedora (util-linux rename):
rename ' ' '_' -- *\ *
```

### Interview Angle

Emphasize quoting, `-print0` + `-d ''` to handle any weird characters safely.

---

## 8) Compare two directories and find differences in files.

### Quick Comparison

```bash
diff -rq dirA dirB
```

### Detailed Content Diffs for Changed Files

```bash
diff -ruN dirA dirB | less
```

### Hash-Based Verify

```bash
( cd dirA && find . -type f -print0 | sort -z | xargs -0 md5sum ) > /tmp/a.md5
( cd dirB && find . -type f -print0 | sort -z | xargs -0 md5sum ) > /tmp/b.md5
diff -u /tmp/a.md5 /tmp/b.md5
```

### Interview Angle

Explain when you need **metadata vs content** comparison, and the cost of hashing large trees.

---

## 9) User cannot create files in a directory, but `ls -l` shows they have write permission.

### Hidden Causes

1. **No execute bit on directory** (need `wx` to create, `x` to traverse):

   ```bash
   chmod u+rwx /shared/dir
   ```
2. **Filesystem is full or out of inodes**:

   ```bash
   df -h
   df -i
   ```
3. **ACL denies write**:

   ```bash
   getfacl /shared/dir
   ```
4. **Immutable attribute** set on directory:

   ```bash
   lsattr /shared/dir
   chattr -i /shared/dir
   ```
5. **Quota exceeded**:

   ```bash
   quota -u username
   ```

### Interview Angle

Call out **directory execute bit** and **inode exhaustion** as frequent real-world culprits.

---

## 10) A symbolic link you created is broken. How do you troubleshoot and fix it?

### Diagnose

```bash
ls -l linkname
readlink -f linkname     # resolve where it points
file linkname
```

Look for:

* Target path exists?
* Was it a **relative** link that became invalid after moving dirs?
* Permissions/SELinux context on target?

### Fix Patterns

* Recreate with correct target:

  ```bash
  ln -sfn /correct/absolute/path target_link
  ```
* Prefer **relative** symlinks inside relocatable trees:

  ```bash
  ln -s ../shared/config.yaml app/config.yaml
  ```
* Repair SELinux type if needed:

  ```bash
  restorecon -Rv /path/to/target /path/to/link
  ```

### Preventive Practice

* In deploy pipelines, build symlinks during install with absolute paths for service files, relative paths inside app trees.
* Validate in CI:

  ```bash
  find . -type l ! -exec test -e {} \; -print
  ```

### Interview Angle

Show `readlink -f` to resolve chains, clarify relative vs absolute links, and mention idempotent recreation using `ln -sfn`.

---

## Appendices

### Useful One-Liners

* Count files quickly in a directory:

  ```bash
  find /path -type f -printf '.' | wc -c
  ```
* Remove only empty directories:

  ```bash
  find /path -type d -empty -delete
  ```

### Operational Guardrails

* Always dry-run destructive `find -delete` operations with `-print` first.
* Exclude pseudo filesystems when scanning from `/`:

  ```bash
  find / -xdev -type f ...
  ```

### Storyline Template for Interviews

* Situation: what broke (file deleted / perms / scale).
* Investigation: exact commands you ran.
* Root Cause: specific bit/ACL/policy/mount option.
* Fix: precise command and verification.
* Prevention: snapshotting, backups, CI checks, policies.

